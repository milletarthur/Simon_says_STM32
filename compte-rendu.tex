\documentclass[10pt,a4,french]{article}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[margin=3cm]{geometry}

\title{Compte-Rendu TP SPC}
\author{Arthur MILLET\\ Rémi GAULMIN}
\date{19 Mars 2024}

\begin{document}

\lstset{language=C, frame=single}

\maketitle

\section{Prise en main de la carte}

\subsection{Les GPIO}

\begin{itemize}
	\item Programme qui allume la LED lorsque le bouton est enfoncé :
		\begin{lstlisting}
int main() {
	init_PB();
	init_LD2();
	while(1){
		if((GPIOC.IDR & (0x1 <<13))==0)
			GPIOA.ODR |= (0x1 << 5);
		else
			GPIOA.ODR &= (~(0x1 <<5));
	}
	return 0;
}
		\end{lstlisting}
	\item Programme qui fait clignoter la LED toutes les 500ms :
		\begin{lstlisting}
int main() {
	init_PB();
	init_LD2();
	while(1){
		GPIOA.ODR &= (~(0x1 << 5));
		tempo_500ms();
		GPIOA.ODR |= (0x1 <<5);
		tempo_500ms();
	}
	return 0;
}
		\end{lstlisting}
	\item Programme qui fait clignoter la LED avec une période de 2s quand le bouton est relâché, et l'allume sur l'appui du bouton :
		\begin{lstlisting}
void tempo_2s() {
	tempo_500ms();
	tempo_500ms();
	tempo_500ms();
	tempo_500ms();
}

int main() {
	init_PB();
	init_LD2();
	while(1) {
		if((GPIOC.IDR & (0x1 << 13)) == 0)
			GPIOA.ODR |= (0x1 <<5);
		else {
			GPIOA.ODR |= (0x1 <<5);
			tempo_2s();
			GPIOA.ODR &= (~(0x1 << 5));
			tempo_2s();
		}
	}
}
		\end{lstlisting}
		Lorsqu'on appuie sur le bouton alors que la LED est éteinte, le programme va d'abord attendre que les deux secondes se soient écoulées (fonction \texttt{tempo\_2s}) avant de reboucler et de tester l'état du bouton.

\subsection{Mise en oeuvre de l'USART}

	\item Programme qui qui réalise l'affichage du caractère entré au clavier :
		\begin{lstlisting}
char _getc(){
	while( (USART2.SR & (0x1 << 5)) == 0);
	return USART2.DR;
}

int main() {
	while(1) {
		char c = _getc();
		if (c =='\r')
			printf("\r\n");
		else
			printf("%c",c);
	}
	return 0;
}
		\end{lstlisting}

	\item Programme qui récupère une chaîne depuis la ligne série et l'affiche deux fois :
		\begin{lstlisting}
int main() {
	char s[256];
	uint32_t i = 0;
	while(1) {
		char c = _getc();
		s[i] = c;
		i = (i+1)%256;
		if (c=='\r'){
			printf("\r\n");
			s[i]='\0';
			i=0;
			_puts(s);
		}
		else
			printf("%c",c);
	}
	return 0;
}
		\end{lstlisting}

\end{itemize}

\subsection{Le Systick, l'USART et les interruptions}

\begin{itemize}
	\item Programme qui fait clignoter la LED toutes les 500ms, en utilisant les interruptions du Systick :
		\begin{lstlisting}
void __attribute__((interrupt)) SysTick_Handler(){
	if((GPIOA.IDR & (0x1 << 5)) == 0) // Si la LED est eteinte,
		GPIOA.ODR |= (0x1 << 5); // On l'allume
	else
		GPIOA.ODR &= (~(0x1 <<5)); // On l'eteint
	tempo_500ms();
}

int main() {
        init_LD2();
	systick_init(1000);
	while(1) {
	
	}
	return 0;
}
		\end{lstlisting}

	\item Programme qui augmente la fréquence de clignotement en appuyant sur le bouton poussoir :
		\begin{lstlisting}
static volatile uint32_t tempo = 1000;
static volatile uint32_t compteur = 0;

void __attribute__((interrupt)) SysTick_Handler(){
	compteur ++;
	if (compteur >= tempo) {
		if((GPIOA.IDR & (0x1 << 5)) == 0)
			GPIOA.ODR |= (0x1 << 5);
		else
			GPIOA.ODR &= (~(0x1 <<5));
		compteur = 0;
	}
}

int main() {
	init_LD2();
	init_PB();
	systick_init(1000);
	while(1) {
		if ((GPIOC.IDR & (0x1 << 13)) == 0)
			tempo--;
		if (tempo <= 0)
			tempo = 500;
	}
	return 0;
}
		\end{lstlisting}
\end{itemize}

\end{document}
